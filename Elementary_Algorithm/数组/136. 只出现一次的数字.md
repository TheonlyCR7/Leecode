给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

```
输入: [2,2,1]
输出: 1
```


示例 2:

```
输入: [4,1,2,1,2]
输出: 4
```



### 题解

与查找存在重复元素类似  先排序  再查找相邻元素是否重复  

```java
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 1; i = i+2) {
            if (nums[i] != nums[i + 1]) return nums[i];
        }
        // 并未查看最后一位元素
        return nums[nums.length-1];
    }
}
```

执行结果

```
执行用时：4 ms, 在所有 Java 提交中击败了27.84%的用户

内存消耗：40.8 MB, 在所有 Java 提交中击败了55.47%的用户
```





### 官方题解

若不考虑时间，空间的要求，通常解法有三种

*   使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。

*   使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。

*   使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。

都需要额外使用 O(n)*O*(*n*) 的空间，其中 n 是数组长度

使用**位运算**。对于这道题，可使用异或运算。异或运算有以下三个性质

```
1.任何数和0做异或运算，结果仍然是原来的数，即a⊕0=a
2.任何数和其自身做异或运算，结果是0，即a⊕a=0
3.异或运算满足交换律和结合律，即a⊕b⊕a=b⊕a⊕a=b⊕（a⊕a）=b⊕0=b
```

对所给数组进行异或运算

重复元素两两成对  异或运算为0   0再与不重复的元素进行异或   结果还是该元素

即  只需要对所给数组进行异或运算

```java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            single ^= num;
        }
        return single;
    }
}
```





